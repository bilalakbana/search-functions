gfzf() {
    local filter=""
    if [ -n "$*" ] && [ -e "$*" ]; then
        filter="-- $*"
    fi

    export LESS='-R'
    export BAT_PAGER='less -S -R -M -i'

    git log --all \
        --graph --color=always --abbrev=7 --glob="refs/heads/*" \
        --format=format:"%C(bold blue)%h%C(reset) %C(dim white)%an%C(reset)%C(bold yellow)%d%C(reset) %C(white)%s%C(reset) %C(bold green)(%ar)%C(reset)%x1f%H%x1f%S" "$@" | \
        sed -E 's#refs/(heads/|remotes/[^/]+/|tags/)##g' | \
        awk -F$'\x1f' '{
            # Extract branch from %S field (field 3)
            branch = $3
            # Clean up branch name and check if its not a SHA
            if (length(branch) > 0 && !match(branch, /^[0-9a-f]{7,40}$/)) {
                # Add branch to the end of the display line (field 1)
                gsub(/\033\[2;31m/, "", branch)  # Remove any existing color codes
                gsub(/\033\[0m/, "", branch)
                print $1 " \033[2;31m" branch "\033[0m" "\x1f" $2 "\x1f" $3
            } else {
                print $0
            }
        }' | \
        fzf --exact --ansi --no-sort --wrap --layout reverse --tiebreak index \
            --delimiter $'\x1f' --with-nth=1 \
            --preview '
                sha={2}; src={3}
                b=$(printf %s "$src" | sed -E "s#refs/(heads/|remotes/[^/]+/|tags/)##")
                
                # Show commit info (author, date, hash, message) with branch appended to second line
                git show -s --color=always --date=format:"%Y-%m-%d %H:%M:%S" --pretty=format:"%C(magenta)<%an>%C(reset) %C(green)(%ar)%C(reset) %C(cyan)%ad%C(reset) - %C(yellow)%h%C(reset) %C(white dim)<%ae>%C(reset)%n%C(white)%s%C(reset)" "$sha" 2>/dev/null \
                | awk -v branch="$b" -v branch_color="\033[2;31m" -v reset_color="\033[0m" \
                      "NR==1 && length(branch) && !match(branch, /^[0-9a-f]{7,40}$/) {print \$0 \" \" branch_color branch reset_color; next} {print}"
                
                # Show Files section if there are changes
                if git diff-tree --no-commit-id --name-only -r --root "$sha" '"$filter"' 2>/dev/null | grep -q .; then
                  echo
                  printf "\033[31mFiles:\033[0m\n"
                  git show --color=always --format= --name-status "$sha" '"$filter"' 2>/dev/null
                  echo
                fi
                
                printf "\033[31mDiffs:\033[0m"
                if command -v delta >/dev/null 2>&1; then
                  git show --color=always --format= "$sha" '"$filter"' 2>/dev/null | delta --line-numbers
                else
                  git show --color=always --format= "$sha" '"$filter"' 2>/dev/null
                fi
            ' \
            --border top \
            --border-label " $(echo $PWD | sed "s/^[^/]\\+$/\x1b[32m&/" | sed "s/\\(.*\\/\\)\\(.*\\)/\x1b[34m\\1\x1b[32m\\2/" | sed "s/\//\x1b[33m\/\x1b[34m/g") " \
            --color 'fg:252,fg+:252,bg:234,bg+:235,hl:magenta,hl+:magenta,info:144,border:240,prompt:161,pointer:161,marker:118,spinner:118,header:168' \
            --bind 'ctrl-l:toggle-preview' \
            --bind 'alt-up:preview-page-up' \
            --bind 'alt-down:preview-page-down' \
            --bind 'home:first,end:last' \
            --bind 'ctrl-alt-h:unix-line-discard' \
            --bind 'alt-bs:unix-word-rubout' \
            --bind 'ctrl-h:backward-kill-word' \
            --preview-window up:55%:wrap
}
logs() {
    COLUMNS=$(tput cols)
    HR=$(printf '%*s' "$COLUMNS" '' | tr ' ' '-')
    FORMAT="$HR%n%C(magenta)<%an>%C(reset) %C(green)(%ar)%C(reset) %C(cyan)%ad%C(reset) - %C(yellow)%h%C(reset) %C(white dim)<%ae>%C(reset) %C(red dim)%S%C(reset)%n"
    DATEOPT="--date=format:%Y-%m-%d %H:%M:%S"

    local path_arg=""
    local git_args=()
    local original_dir="$PWD"

    for arg in "$@"; do
        if [[ -z "$path_arg" && -e "$arg" ]]; then
            path_arg=$(readlink -f "$arg")
        else
            git_args+=("$arg")
        fi
    done

    if [[ -n "$path_arg" ]]; then
        if [[ -d "$path_arg" ]]; then
            is_dir=true
            dir="$path_arg"
        else
            is_dir=false
            dir=$(dirname "$path_arg")
        fi

        cd "$dir" || { echo -e "\033[31mCannot cd into target directory.\033[0m"; return; }

        repo_root=$(git rev-parse --show-toplevel 2>/dev/null)
        if [[ -z "$repo_root" ]]; then
            echo -e "\033[31mNot inside a Git repository.\033[0m"
            cd "$original_dir"
            return
        fi

        submodule_path=$(cd "$repo_root" && git config --file .gitmodules --get-regexp path 2>/dev/null | while read -r _ path; do
            [[ "$path_arg" == *"/$path/"* || "$path_arg" == *"/$path" ]] && echo "$path" && break
        done)

        if [[ -n "$submodule_path" ]]; then
            relative_path="${path_arg#*$submodule_path/}"
            cd "$repo_root/$submodule_path" || {
                echo -e "\033[31mCannot cd into submodule.\033[0m"
                cd "$original_dir"
                return
            }
        else
            relative_path="${path_arg#$repo_root/}"
            cd "$repo_root" || {
                echo -e "\033[31mCannot cd into repo root.\033[0m"
                cd "$original_dir"
                return
            }
        fi

        if [[ "$is_dir" == false ]]; then
            if ! git ls-files --error-unmatch "$relative_path" >/dev/null 2>&1; then
                echo -e "\033[31m⚡ File is not tracked in Git:\033[0m $relative_path"
                cd "$original_dir"
                return
            fi
        else
            if ! git ls-files "$relative_path" | grep -q .; then
                echo -e "\033[31m⚡ No tracked files found under directory:\033[0m $relative_path"
                cd "$original_dir"
                return
            fi
        fi

        git log --all --color=always --pretty=format:"$FORMAT" "$DATEOPT" --name-status "${git_args[@]}" -- "$relative_path" | sed -E 's#refs/(heads/|remotes/[^/]+/|tags/)##' | less -R -i --mouse
        cd "$original_dir"
        return
    fi

    # Default case: no file/dir passed
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo -e "\033[31mNot inside a Git repository.\033[0m"
        return
    fi

    git log --all --color=always --pretty=format:"$FORMAT" "$DATEOPT" --name-status "$@" | sed -E 's#refs/(heads/|remotes/[^/]+/|tags/)##' | less -R -i --mouse
}
logs-and-diffs() {
    COLUMNS=$(tput cols)
    HR=$(printf '%*s' "$COLUMNS" '' | tr ' ' '-')

    # Colors
    BRANCH_COLOR="\033[2;31m"   # red
    RESET_COLOR="\033[0m"

    # Header WITHOUT %S; we append branch manually (like logs())
    FORMAT_BASE="$HR%n%C(magenta)<%an>%C(reset) %C(green)(%ar)%C(reset) %C(cyan)%ad%C(reset) - %C(yellow)%h%C(reset) %C(white dim)<%ae>%C(reset)%n%C(white)%s%C(reset)"
    DATEOPT="--date=format:%Y-%m-%d %H:%M:%S"

    local path_arg=""
    local git_args=()
    local original_dir="$PWD"

    for arg in "$@"; do
        if [[ -z "$path_arg" && -e "$arg" ]]; then
            path_arg=$(readlink -f "$arg")
        else
            git_args+=("$arg")
        fi
    done

    _clean_ref() {
        sed -E 's#refs/(heads/|remotes/[^/]+/|tags/)##'
    }

    _show_commit() {
        local sha="$1"
        local src="$2"    # %S captured from the producer pass
        [[ -z "$sha" ]] && return   # safety guard

        local branch=""
        if [[ -n "$src" ]]; then
            branch=$(printf '%s' "$src" | _clean_ref)
            [[ "$branch" =~ ^[0-9a-f]{7,40}$ ]] && branch=""
        fi

        # Header (append branch to second line)
        git show -s --color=always "$DATEOPT" --pretty=format:"$FORMAT_BASE" "$sha" \
        | awk -v b="$branch" -v c="$BRANCH_COLOR" -v r="$RESET_COLOR" \
              'NR==2 && length(b){print $0 " " c b r; next} {print}'

        # Show Files/Diffs only if there are changes (handles root commit too)
        if git diff-tree --no-commit-id --name-only -r --root "$sha" | grep -q .; then
            echo
            printf "\033[31mFiles:\033[0m\n"
            git show --color=always --format= --name-status "$sha"
            echo

            printf "\033[31mDiffs:\033[0m"
            if command -v delta >/dev/null 2>&1; then
                git show --color=always --format= -p "$sha" \
                | delta --width="$COLUMNS" --line-numbers \
                        --minus-style="syntax gray" --plus-style="syntax gray"
            else
                git show --color=always --format= -p "$sha"
            fi
        fi

        # exactly one blank line between commits
        echo
    }

    if [[ -n "$path_arg" ]]; then
        if [[ -d "$path_arg" ]]; then is_dir=true; dir="$path_arg"; else is_dir=false; dir=$(dirname "$path_arg"); fi
        cd "$dir" || { echo -e "\033[31mCannot cd into target directory.\033[0m"; return; }

        repo_root=$(git rev-parse --show-toplevel 2>/dev/null)
        if [[ -z "$repo_root" ]]; then echo -e "\033[31mNot inside a Git repository.\033[0m"; cd "$original_dir"; return; fi

        submodule_path=$(cd "$repo_root" && git config --file .gitmodules --get-regexp path 2>/dev/null | while read -r _ path; do
            [[ "$path_arg" == *"/$path/"* || "$path_arg" == *"/$path" ]] && echo "$path" && break
        done)

        if [[ -n "$submodule_path" ]]; then
            relative_path="${path_arg#*$submodule_path/}"
            cd "$repo_root/$submodule_path" || { echo -e "\033[31mCannot cd into submodule.\033[0m"; cd "$original_dir"; return; }
        else
            relative_path="${path_arg#$repo_root/}"
            cd "$repo_root" || { echo -e "\033[31mCannot cd into repo root.\033[0m"; cd "$original_dir"; return; }
        fi

        git log --all --pretty=format:'%H%x1f%S' "${git_args[@]}" -- "$relative_path" \
        | while IFS=$'\x1f' read -r sha src || [[ -n "$sha" ]]; do _show_commit "$sha" "$src"; done \
        | less -R -i --mouse

        cd "$original_dir"; return
    fi

    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo -e "\033[31mNot inside a Git repository.\033[0m"; return
    fi

    git log --all --pretty=format:'%H%x1f%S' "${git_args[@]}" \
    | while IFS=$'\x1f' read -r sha src || [[ -n "$sha" ]]; do _show_commit "$sha" "$src"; done \
    | less -R -i --mouse
}
logs-and-diffs-sbs() {
    COLUMNS=$(tput cols)
    HR=$(printf '%*s' "$COLUMNS" '' | tr ' ' '-')

    # Colors
    BRANCH_COLOR="\033[2;31m"   # red
    RESET_COLOR="\033[0m"

    # Header WITHOUT %S; we append branch manually (like logs())
    FORMAT_BASE="$HR%n%C(magenta)<%an>%C(reset) %C(green)(%ar)%C(reset) %C(cyan)%ad%C(reset) - %C(yellow)%h%C(reset) %C(white dim)<%ae>%C(reset)%n%C(white)%s%C(reset)"
    DATEOPT="--date=format:%Y-%m-%d %H:%M:%S"

    local path_arg=""
    local git_args=()
    local original_dir="$PWD"

    for arg in "$@"; do
        if [[ -z "$path_arg" && -e "$arg" ]]; then
            path_arg=$(readlink -f "$arg")
        else
            git_args+=("$arg")
        fi
    done

    _clean_ref() {
        sed -E 's#refs/(heads/|remotes/[^/]+/|tags/)##'
    }

    _show_commit() {
        local sha="$1"
        local src="$2"    # %S captured from the producer pass
        [[ -z "$sha" ]] && return   # safety guard

        local branch=""
        if [[ -n "$src" ]]; then
            branch=$(printf '%s' "$src" | _clean_ref)
            [[ "$branch" =~ ^[0-9a-f]{7,40}$ ]] && branch=""
        fi

        # Header (append branch to second line)
        git show -s --color=always "$DATEOPT" --pretty=format:"$FORMAT_BASE" "$sha" \
        | awk -v b="$branch" -v c="$BRANCH_COLOR" -v r="$RESET_COLOR" \
              'NR==2 && length(b){print $0 " " c b r; next} {print}'

        # Show Files/Diffs only if there are changes (handles root commit too)
        if git diff-tree --no-commit-id --name-only -r --root "$sha" | grep -q .; then
            echo
            printf "\033[31mFiles:\033[0m\n"
            git show --color=always --format= --name-status "$sha"
            echo

            printf "\033[31mDiffs:\033[0m"
            if command -v delta >/dev/null 2>&1; then
                git show --color=always --format= -p "$sha" \
                | delta --side-by-side --width="$COLUMNS" --line-numbers \
                        --minus-style="syntax gray" --plus-style="syntax gray"
            else
                git show --color=always --format= -p "$sha"
            fi
        fi

        # exactly one blank line between commits
        echo
    }

    if [[ -n "$path_arg" ]]; then
        if [[ -d "$path_arg" ]]; then is_dir=true; dir="$path_arg"; else is_dir=false; dir=$(dirname "$path_arg"); fi
        cd "$dir" || { echo -e "\033[31mCannot cd into target directory.\033[0m"; return; }

        repo_root=$(git rev-parse --show-toplevel 2>/dev/null)
        if [[ -z "$repo_root" ]]; then echo -e "\033[31mNot inside a Git repository.\033[0m"; cd "$original_dir"; return; fi

        submodule_path=$(cd "$repo_root" && git config --file .gitmodules --get-regexp path 2>/dev/null | while read -r _ path; do
            [[ "$path_arg" == *"/$path/"* || "$path_arg" == *"/$path" ]] && echo "$path" && break
        done)

        if [[ -n "$submodule_path" ]]; then
            relative_path="${path_arg#*$submodule_path/}"
            cd "$repo_root/$submodule_path" || { echo -e "\033[31mCannot cd into submodule.\033[0m"; cd "$original_dir"; return; }
        else
            relative_path="${path_arg#$repo_root/}"
            cd "$repo_root" || { echo -e "\033[31mCannot cd into repo root.\033[0m"; cd "$original_dir"; return; }
        fi

        git log --all --pretty=format:'%H%x1f%S' "${git_args[@]}" -- "$relative_path" \
        | while IFS=$'\x1f' read -r sha src || [[ -n "$sha" ]]; do _show_commit "$sha" "$src"; done \
        | less -R -i --mouse

        cd "$original_dir"; return
    fi

    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo -e "\033[31mNot inside a Git repository.\033[0m"; return
    fi

    git log --all --pretty=format:'%H%x1f%S' "${git_args[@]}" \
    | while IFS=$'\x1f' read -r sha src || [[ -n "$sha" ]]; do _show_commit "$sha" "$src"; done \
    | less -R -i --mouse
}
logs-and-diffs-full() {
    COLUMNS=$(tput cols)
    HR=$(printf '%*s' "$COLUMNS" '' | tr ' ' '-')

    # Colors
    BRANCH_COLOR="\033[2;31m"   # red
    RESET_COLOR="\033[0m"

    # Header WITHOUT %S; we append branch manually (like logs())
    FORMAT_BASE="$HR%n%C(magenta)<%an>%C(reset) %C(green)(%ar)%C(reset) %C(cyan)%ad%C(reset) - %C(yellow)%h%C(reset) %C(white dim)<%ae>%C(reset)%n%C(white)%s%C(reset)"
    DATEOPT="--date=format:%Y-%m-%d %H:%M:%S"

    local path_arg=""
    local git_args=()
    local original_dir="$PWD"

    for arg in "$@"; do
        if [[ -z "$path_arg" && -e "$arg" ]]; then
            path_arg=$(readlink -f "$arg")
        else
            git_args+=("$arg")
        fi
    done

    _clean_ref() {
        sed -E 's#refs/(heads/|remotes/[^/]+/|tags/)##'
    }

    _show_commit() {
        local sha="$1"
        local src="$2"    # %S captured from the producer pass
        [[ -z "$sha" ]] && return   # safety guard

        local branch=""
        if [[ -n "$src" ]]; then
            branch=$(printf '%s' "$src" | _clean_ref)
            [[ "$branch" =~ ^[0-9a-f]{7,40}$ ]] && branch=""
        fi

        # Header (append branch to second line)
        git show -s --color=always "$DATEOPT" --pretty=format:"$FORMAT_BASE" "$sha" \
        | awk -v b="$branch" -v c="$BRANCH_COLOR" -v r="$RESET_COLOR" \
              'NR==2 && length(b){print $0 " " c b r; next} {print}'

        # Show Files/Diffs only if there are changes (handles root commit too)
        if git diff-tree --no-commit-id --name-only -r --root "$sha" | grep -q .; then
            echo
            printf "\033[31mFiles:\033[0m\n"
            git show --color=always --format= --name-status "$sha"
            echo

            printf "\033[31mDiffs:\033[0m"
            if command -v delta >/dev/null 2>&1; then
                git show --color=always --format= -p --unified=99999999999 "$sha" \
                | delta --width="$COLUMNS" --line-numbers \
                        --minus-style="syntax gray" --plus-style="syntax gray"
            else
                git show --color=always --format= -p --unified=99999999999 "$sha"
            fi
        fi

        # exactly one blank line between commits
        echo
    }

    if [[ -n "$path_arg" ]]; then
        if [[ -d "$path_arg" ]]; then is_dir=true; dir="$path_arg"; else is_dir=false; dir=$(dirname "$path_arg"); fi
        cd "$dir" || { echo -e "\033[31mCannot cd into target directory.\033[0m"; return; }

        repo_root=$(git rev-parse --show-toplevel 2>/dev/null)
        if [[ -z "$repo_root" ]]; then echo -e "\033[31mNot inside a Git repository.\033[0m"; cd "$original_dir"; return; fi

        submodule_path=$(cd "$repo_root" && git config --file .gitmodules --get-regexp path 2>/dev/null | while read -r _ path; do
            [[ "$path_arg" == *"/$path/"* || "$path_arg" == *"/$path" ]] && echo "$path" && break
        done)

        if [[ -n "$submodule_path" ]]; then
            relative_path="${path_arg#*$submodule_path/}"
            cd "$repo_root/$submodule_path" || { echo -e "\033[31mCannot cd into submodule.\033[0m"; cd "$original_dir"; return; }
        else
            relative_path="${path_arg#$repo_root/}"
            cd "$repo_root" || { echo -e "\033[31mCannot cd into repo root.\033[0m"; cd "$original_dir"; return; }
        fi

        git log --all --pretty=format:'%H%x1f%S' "${git_args[@]}" -- "$relative_path" \
        | while IFS=$'\x1f' read -r sha src || [[ -n "$sha" ]]; do _show_commit "$sha" "$src"; done \
        | less -R -i --mouse

        cd "$original_dir"; return
    fi

    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo -e "\033[31mNot inside a Git repository.\033[0m"; return
    fi

    git log --all --pretty=format:'%H%x1f%S' "${git_args[@]}" \
    | while IFS=$'\x1f' read -r sha src || [[ -n "$sha" ]]; do _show_commit "$sha" "$src"; done \
    | less -R -i --mouse
}
logs-and-diffs-full-sbs() {
    COLUMNS=$(tput cols)
    HR=$(printf '%*s' "$COLUMNS" '' | tr ' ' '-')

    # Colors
    BRANCH_COLOR="\033[2;31m"   # red
    RESET_COLOR="\033[0m"

    # Header WITHOUT %S; we append branch manually (like logs())
    FORMAT_BASE="$HR%n%C(magenta)<%an>%C(reset) %C(green)(%ar)%C(reset) %C(cyan)%ad%C(reset) - %C(yellow)%h%C(reset) %C(white dim)<%ae>%C(reset)%n%C(white)%s%C(reset)"
    DATEOPT="--date=format:%Y-%m-%d %H:%M:%S"

    local path_arg=""
    local git_args=()
    local original_dir="$PWD"

    for arg in "$@"; do
        if [[ -z "$path_arg" && -e "$arg" ]]; then
            path_arg=$(readlink -f "$arg")
        else
            git_args+=("$arg")
        fi
    done

    _clean_ref() {
        sed -E 's#refs/(heads/|remotes/[^/]+/|tags/)##'
    }

    _show_commit() {
        local sha="$1"
        local src="$2"    # %S captured from the producer pass
        [[ -z "$sha" ]] && return   # safety guard

        local branch=""
        if [[ -n "$src" ]]; then
            branch=$(printf '%s' "$src" | _clean_ref)
            [[ "$branch" =~ ^[0-9a-f]{7,40}$ ]] && branch=""
        fi

        # Header (append branch to second line)
        git show -s --color=always "$DATEOPT" --pretty=format:"$FORMAT_BASE" "$sha" \
        | awk -v b="$branch" -v c="$BRANCH_COLOR" -v r="$RESET_COLOR" \
              'NR==2 && length(b){print $0 " " c b r; next} {print}'

        # Show Files/Diffs only if there are changes (handles root commit too)
        if git diff-tree --no-commit-id --name-only -r --root "$sha" | grep -q .; then
            echo
            printf "\033[31mFiles:\033[0m\n"
            git show --color=always --format= --name-status "$sha"
            echo

            printf "\033[31mDiffs:\033[0m"
            if command -v delta >/dev/null 2>&1; then
                git show --color=always --format= -p --unified=99999999999 "$sha" \
                | delta --side-by-side --width="$COLUMNS" --line-numbers \
                        --minus-style="syntax gray" --plus-style="syntax gray"
            else
                git show --color=always --format= -p --unified=99999999999 "$sha"
            fi
        fi

        # exactly one blank line between commits
        echo
    }

    if [[ -n "$path_arg" ]]; then
        if [[ -d "$path_arg" ]]; then is_dir=true; dir="$path_arg"; else is_dir=false; dir=$(dirname "$path_arg"); fi
        cd "$dir" || { echo -e "\033[31mCannot cd into target directory.\033[0m"; return; }

        repo_root=$(git rev-parse --show-toplevel 2>/dev/null)
        if [[ -z "$repo_root" ]]; then echo -e "\033[31mNot inside a Git repository.\033[0m"; cd "$original_dir"; return; fi

        submodule_path=$(cd "$repo_root" && git config --file .gitmodules --get-regexp path 2>/dev/null | while read -r _ path; do
            [[ "$path_arg" == *"/$path/"* || "$path_arg" == *"/$path" ]] && echo "$path" && break
        done)

        if [[ -n "$submodule_path" ]]; then
            relative_path="${path_arg#*$submodule_path/}"
            cd "$repo_root/$submodule_path" || { echo -e "\033[31mCannot cd into submodule.\033[0m"; cd "$original_dir"; return; }
        else
            relative_path="${path_arg#$repo_root/}"
            cd "$repo_root" || { echo -e "\033[31mCannot cd into repo root.\033[0m"; cd "$original_dir"; return; }
        fi

        git log --all --pretty=format:'%H%x1f%S' "${git_args[@]}" -- "$relative_path" \
        | while IFS=$'\x1f' read -r sha src || [[ -n "$sha" ]]; do _show_commit "$sha" "$src"; done \
        | less -R -i --mouse

        cd "$original_dir"; return
    fi

    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo -e "\033[31mNot inside a Git repository.\033[0m"; return
    fi

    git log --all --pretty=format:'%H%x1f%S' "${git_args[@]}" \
    | while IFS=$'\x1f' read -r sha src || [[ -n "$sha" ]]; do _show_commit "$sha" "$src"; done \
    | less -R -i --mouse
}
